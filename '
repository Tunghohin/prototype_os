#![allow(dead_code)]

use {
    crate::mm::linked_list,
    core::{
        alloc::{GlobalAlloc, Layout},
        cmp::{max, min},
        mem::size_of,
        ptr::NonNull,
    },
};

const MAX_ORDER: usize = 64;

pub struct Heap {
    // buddy system with max order of 32
    free_list: [linked_list::LinkedList; MAX_ORDER],

    // statistics
    user: usize,
    allocated: usize,
    total: usize,
}

impl Heap {
    fn new() -> Self {
        Heap {
            free_list: [linked_list::LinkedList::new(); MAX_ORDER],
            user: 0,
            allocated: 0,
            total: 0,
        }
    }

    fn empty() -> Self {
        Self::new()
    }

    pub unsafe fn init(&mut self, mut start: usize, mut end: usize) {
        // avoid unaligned access on some platforms
        start = (start + size_of::<usize>() - 1) & (!size_of::<usize>() + 1);
        end = end & (!size_of::<usize>() + 1);
        assert!(start <= end);

        let mut current_start = start;
        while current_start + size_of::<usize>() <= end {
            let low_bit = current_start & (!current_start + 1);
            let size = min(low_bit, prev_power_of_two(end - current_start));
            self.total += size;
            self.free_list[size.trailing_zeros() as usize].push(current_start as *mut usize);
            current_start += size;
        }
    }

    pub fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, ()> {
        let size = max(
            layout.size().next_power_of_two(),
            max(layout.align(), size_of::<usize>()),
        );

        let alloc_type = size.trailing_zeros() as usize;
        let split_pos = match (alloc_type..MAX_ORDER).find(|&i| !self.free_list[i].is_empty()) {
            Some(split_pos) => split_pos,
            None => {
                return Err(());
            }
        };

        (alloc_type..split_pos).rev().for_each(|i| {
            let seg = self.free_list[i]
                .pop()
                .expect("current block should have free space now");
            self.free_list[i - 1].push(seg);
            self.free_list[i - 1].push((seg as usize + (1 << (i - 1))) as *mut usize);
        });

        if let Some(result) = NonNull::new(
            self.free_list[alloc_type]
                .pop()
                .expect("current block should have free space now") as *mut u8,
        ) {
            self.user += layout.size();
            self.allocated += size;
            Ok(result)
        } else {
            Err(())
        }
    }

    pub fn dalloc(&mut self, ptr: NonNull<u8>, layout: Layout) {
        let size = max(
            layout.size().next_power_of_two(),
            max(layout.align(), size_of::<usize>()),
        );
        let alloc_type = size.trailing_zeros() as usize;

        self.free_list[alloc_type].push(ptr.as_ptr() as *mut usize);

        let current_ptr = ptr.as_ptr();
        let current_type = alloc_type;
    }
}

/// return the largest power of two less or equal to num
/// just do 1 shift left sizeof usize minus leading zeros of num
/// #Example
/// basic_usage:
/// ```
/// assert_eq!(prev_power_of_two(0b00100100), 0b100000);
/// ```
pub(crate) fn prev_power_of_two(num: usize) -> usize {
    1 << (8 * (size_of::<usize>()) - num.leading_zeros() as usize - 1)
}
